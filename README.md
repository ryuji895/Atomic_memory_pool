# Atomic_memory_pool

注意、このコードはTaggedValueとTaggedValueUnionはAIのコードを元にし、すこし改造したものです。それ以外は完全自作となっています。

64bitのx86_64のCPUで動く前提です、必ずhaswell世代以降で使ってください、そうじゃないと、CMPXCHG16Bが使えないから

このリポジトリで紹介してるメモリプールはC言語で書かれてます。
私は昔のコンピュータがどのようにして藤原拓海がAE86の限界を引き出すようにプログラミングしていたのかを調べた時に非同期プログラミングに辿り着きました。
そこで私は遊びでまぁまぁ速いloginシステムを作ってみることにしました、最初はmallocで一々user_info_tなどの構造体を確保していたのですが、メモリプー
ルを使えば最初から確保するサイズが確実かつ、mallocとfreeの命令が省けると思い、最初っからuser_info_t memory_pool[64][64]のように静的に確保しする
構造を思いつきました。
これなら最初っから決まった構造体の物を決まったサイズ確保しているので命令を削ることができ、なおかつメモリが枯渇するという問題もありません。

ここで私はメモリを管理するにあたって、bitフラグで管理することにしました。bitが0のところが空いてるとして、__builtin_ctzll()でuint64_tのフラグを反転させたものから1までの値を検索してその場所を使用する手法を思いつきました。
この時、自分はatomicを知る前夜でしたから今までどおり、mutexを使うことにしました、もともとソケットプールもリングバッファをmutexで実装していたためmutexが慣れていたからです。
pthread_mutex_t mutex[64]をmemory_poolの2つ目の[]にしました1つ目の[]のフラグを検索するのは不確実性が在っても仕方無い、ここでmutexを使ったら速度的に見て良さが失われると思ったからです。
そこで私は1つ目の[]は普通に__builtin_ctzllでuint64_tのflagから検索しました、二つ目の[]は一つ目のflag検索で空いてる場所の値を入れたものでまずmutexをtrylockできるか試して、駄目であれば1段階目からやり直す設計でした。
勿論、__builtin_ctzllが0の状態でやるとエラーを出してしまうことは知っているためif(__builtin_expect(flag==UINT64_MAX,0))をやってから検索しました。

bitフラグを立てたり降ろしたりすることは皆さんわかってると思うので割愛しますね☆

私はそのコードを完成させ見た時に違和感を感じました。これじゃー。非同期性が足りないんじゃないか？
当時からloginシステム自体はepollにより、計算と通信を完全に分割していたので、、、その話はどうでも良くて、とにかく自分に満足できなかったのでもっと速くなりたいってAIに相談したらatomicについて教えてもらったので早速atomicとmemory_orderを6つ暗記して（結局使ったのはmemory_order_acquireとmemory_order_releaseだけだったけど)使ってみることにしました。

するとatomicというのは原理的には、一貫性を保証、つまり、メモリをいじってる時に他の処理が割り込まないことを保証しているわけですので、一貫性が保たれているわけです、そのうえ、速いしatomic_compare_exchange_strong_explicitを使ってmemory_order_seq_cstを全部使う設計でした、自分は元々セキュリティ意識と完全性を重視する人間ですので、、、

しかし、AIにコードを見せたらABA問題を指摘され、その解決としてバージョンカウンタを教えてもらいました。正直言って悔しかったです（自分で思いつかなかったから）

ABA問題ってのは、メモリからCPUにデータをatomicで処理してる間に他のコアがそのメモリに書き込んでそんで元々atomic的に処理していた内容を書き込んで元の値が違うにもかかわらず、変更された値を無視して書き込んでしまうことで発生してしまいます。

そこでAIのヒントをそのまま利用するのでは悔しいため少し工夫したり、試行錯誤することにしました。
まずAIのバージョンカウンタは、void *つまり、メモリのアドレスと単純なuint64_tを組み合わせて、最終的にはunion型でunsigend __int128として扱えるようにし、
atomic_compare_change_strongでバージョンカウンタとアドレスどっちらかが違ければ失敗するという内容でした。私にはこの時改善の余地があると直感てきに思いました。

まず、unsigend __int128の案はそのまま採用しました、あとuint64_tのバージョンカウンタも、しかし、私はメモリプールのアクセスを高速にしたかった、そして、mallocではなく、静的に予め確保したメモリプールで動かしたかったので、メモリアドレスが毎回変わってしまっては意味がないと直に直感しました。

まず、思いついたのは本質的には変数の変化とそのバージョンがまだ編集されていないバージョンかを比較して、同じなら、予め用意して置いたものに入れ替えるという本質だと考えました、ここで思ったのは、変化を記録している本質、つまり、64bitのフラグをvoid *ではなく、uint64_tを直接使うことでした、これにより、一々違う、場所の変数を使うという考えをしなくてすみました、（たまたまuint64_tで管理していたのが運が良かった）

私はAIになぜ、unionにするのか尋ねたところ、CMPXCHG16Bを利用するためと帰ってきました。
CMPXCHG16Bはhaswell世代から追加された命令セットらしくて、128bitずつ比較できるとのこと、(厳密には違うかも、いま色々勉強中)
AIにCでCMPXCHG16Bを扱うことができるのかを聞いたところ無理との回答が帰ってきました、同時に、128bit同士の演算ならワンちゃんあるとのこと、
というわけで、もともとAIが教えてくれた__int128 unionを採用することにしました、変数名もAIが教えてくれたものとなっています。

そして、私はCからcmpxchg16bを呼び出す詠唱を考えました、まず、自分はインラインアセンぶりを扱ったことがないので、Cからがんばることにしました、コード自体はABA問題解決のTaggedValueUnionとTaggedValue以外は全て自分で考えたものなので、これを更に改造しようと思ったのですが、atomic_compare_exchange_strong_explicitをつかって__int128として比較するコードに治すだけでした、

因みに構造体にも少し手を加ました。
typedef struct{
  uint64_t flag;
  uint64_t version;
}
に対して、確実に128bitに揃えるために__attribute((packed,aligned(16)))を追加しました。packedはパディングを追加せず、ダメ押しでデータを16バイト境界で揃えて配置するaligned(16)を追加しました。
とにかく128bitにすることを意識しました。

そして、gccでコンパイル。その後objdump -d -M intel a.bin | grep cmpxchg16bで調べたところ、、、ありませんでした、
そこで、世代に依存するという点をおもいだし、-march=native -O3をつけました、-march=nativeはいま自分がコンパイルしているCPUに最適になるようにするためのgccのコンパイラオプションです。-O3は私が少しでも早くしたいって思いです、普通は-~2で十分です。
そうするとcmpxchg16bを召喚することが成功しました。

長々とした文章を読んでいただきありがとうございます、お力になれたら幸いです。
